import r from 'rethinkdb';
import { connection } from './connection';
import { broadcastChanges } from '../server/socket';
import { challengeTimer } from '../constants/gameSettings';
import { endChallenge } from './endChallenge';
import { shuffle } from 'underscore';

// Attach listener to challenges table and broadcast changes to all socket-connected clients
broadcastChanges();

// preset challenges defined here:
const challengesPreset = [
  ['steps', 5000, 100, 400, Math.floor(Math.random() * challengeTimer)],
  ['steps', 1000, 100, 200, Math.floor(Math.random() * challengeTimer)],
  ['calories', 1000, 100, 400, Math.floor(Math.random() * challengeTimer)],
  ['calories', 500, 100, 200, Math.floor(Math.random() * challengeTimer)],
  ['activity', 30, 100, 200, Math.floor(Math.random() * challengeTimer) + 1800],
  ['distance', 1, 100, 200, Math.floor(Math.random() * challengeTimer)]
];

// Create rethinkdb documents for every challenge
const createChallenge = (category, requirement, wager, reward, timer) => {
  let key = null; // We need to store the key generated by rethinkdb, so we can
                  // look up the document later and set disabled to true

  r.db('fitapp').table('challenges').insert({
    category,
    requirement,
    wager,
    reward,
    members: [],
    end_time: r.now().add(timer),
    disabled: false,
    ended: false
  }).run(connection, (err, result) => {
    if (err) throw err;
    key = result.generated_keys[0];
  });

  // After half the challengeTimer has passed, set disabled to true
  // This is to make it so users can't leave past the halfway point of the challenge
  // Client will be subscribed to changefeed of challenges by then
  setTimeout(() => {
    r.db('fitapp').table('challenges').get(key)
    .update({ disabled: true })
    .run(connection, (err) => {
      if (err) throw err;
    });
  }, timer / 2 * 1000);

  // Do the same for ended when end_time is reached
  setTimeout(() => {
    r.db('fitapp').table('challenges').get(key)
    .update({ ended: true })
    .run(connection, (err) => {
      if (err) throw err;
    });

    endChallenge(key);
  }, timer * 1000);
};

// Clear out old challenges first, then create new ones
r.db('fitapp').table('challenges').delete().run(connection)
.then(() => {
  shuffle(challengesPreset).forEach(challenge => {
    createChallenge(...challenge);
  });
});

setInterval(() => {
  r.db('fitapp').table('challenges').delete().run(connection)
  .then(() => {
    shuffle(challengesPreset).forEach(challenge => {
      createChallenge(...challenge);
    });
  });
}, challengeTimer * 1000 * 1.2);
